<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>
    <link rel="icon" href="https://i.mji.rip/2025/10/10/233dd815c949e025f1251a319cb22724.jpeg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="使用Python编写，适合windows7 32位及以上系统，整体功能纯净无广告
软件名称：NTP同步
图形界面（tkinter + 系统托盘）
自定义 NTP 服务器 & 同步间隔
无黑框（使用 pythonw 或打包后自动隐藏）
圆形蓝色托盘图标（带时钟指针）
开机启动开关按钮
通过 Windows API 设置时间
以管理员身份自动提权
兼容 Windows 7 32位 + Python 3.8

编译所需要的依赖
```
pip install ntplib pystray pillow
```
打包成软件
```
pyinstaller --onefile --windowed --name 'NTP同步' ntp_gui.py
```
⚠️ 重要提醒

- 首次运行会弹出 UAC 提权窗口（正常现象）

- 若仍提示“设置系统时间失败”，请手动授予当前用户 “更改系统时间”权限（通过 secpol.msc）
- 开机启动功能写入 当前用户 启动项，无需管理员权限

---
ntp_gui.py
```
# ntp_gui.py - NTP同步（Windows 7 32位兼容版）
# 功能：图形界面 + 系统托盘 + 开机启动 + 无黑框 + 权限提取

import os
import sys
import time
import threading
import subprocess
from datetime import datetime, timezone
import tkinter as tk
from tkinter import ttk, messagebox
import ntplib
import pystray
from PIL import Image, ImageDraw

# Windows 注册表（仅 Windows）
try:
    import winreg as reg
except ImportError:
    reg = None

# ----------------------------
# 工具函数
# ----------------------------

def is_admin():
    try:
        return os.getuid() == 0
    except AttributeError:
        import ctypes
        return ctypes.windll.shell32.IsUserAnAdmin() != 0

def run_as_admin():
    '''以管理员身份重新运行（优先使用 pythonw 避免黑框）'''
    import ctypes
    executable = sys.executable
    if executable.endswith('python.exe'):
        executable = executable[:-10] + 'pythonw.exe'
    script = os.path.abspath(sys.argv[0])
    params = f''{script}''
    try:
        ctypes.windll.shell32.ShellExecuteW(None, 'runas', executable, params, None, 1)
    except Exception:
        pass
    sys.exit(0)

def set_system_time(dt):
    '''使用 Windows API 设置系统时间（支持 Win7 32位）'''
    import ctypes
    from ctypes import wintypes

    class LUID(ctypes.Structure):
        _fields_ = [('LowPart', wintypes.DWORD), ('HighPart', wintypes.LONG)]

    class LUID_AND_ATTRIBUTES(ctypes.Structure):
        _fields_ = [('Luid', LUID), ('Attributes', wintypes.DWORD)]

    class TOKEN_PRIVILEGES(ctypes.Structure):
        _fields_ = [('PrivilegeCount', wintypes.DWORD), ('Privileges', LUID_AND_ATTRIBUTES * 1)]

    def enable_privilege(privilege_name):
        ADVAPI32 = ctypes.windll.advapi32
        KERNEL32 = ctypes.windll.kernel32
        hToken = wintypes.HANDLE()
        if not ADVAPI32.OpenProcessToken(KERNEL32.GetCurrentProcess(), 0x0028, ctypes.byref(hToken)):
            return False
        luid = LUID()
        if not ADVAPI32.LookupPrivilegeValueW(None, privilege_name, ctypes.byref(luid)):
            KERNEL32.CloseHandle(hToken)
            return False
        tp = TOKEN_PRIVILEGES()
        tp.PrivilegeCount = 1
        tp.Privileges[0].Luid = luid
        tp.Privileges[0].Attributes = 2  # SE_PRIVILEGE_ENABLED
        result = ADVAPI32.AdjustTokenPrivileges(hToken, False, ctypes.byref(tp), 0, None, None)
        success = (result != 0) and (KERNEL32.GetLastError() == 0)
        KERNEL32.CloseHandle(hToken)
        return success

    if not enable_privilege('SeSystemtimePrivilege'):
        return False

    class SYSTEMTIME(ctypes.Structure):
        _fields_ = [
            ('wYear', wintypes.WORD),
            ('wMonth', wintypes.WORD),
            ('wDayOfWeek', wintypes.WORD),
            ('wDay', wintypes.WORD),
            ('wHour', wintypes.WORD),
            ('wMinute', wintypes.WORD),
            ('wSecond', wintypes.WORD),
            ('wMilliseconds', wintypes.WORD),
        ]

    st = SYSTEMTIME()
    st.wYear = dt.year
    st.wMonth = dt.month
    st.wDay = dt.day
    st.wHour = dt.hour
    st.wMinute = dt.minute
    st.wSecond = dt.second
    st.wMilliseconds = 0

    return bool(ctypes.windll.kernel32.SetLocalTime(ctypes.byref(st)))

def get_ntp_time(ntp_server):
    client = ntplib.NTPClient()
    try:
        response = client.request(ntp_server, version=3, timeout=5)
        utc_dt = datetime.utcfromtimestamp(response.tx_time).replace(tzinfo=timezone.utc)
        return utc_dt
    except Exception:
        return None

# ----------------------------
# 主应用类
# ----------------------------

class NTPApp:
    def __init__(self, root):
        self.root = root
        self.root.title('NTP同步')
        self.root.geometry('420x260')
        self.root.resizable(False, False)
        self.root.protocol('WM_DELETE_WINDOW', self.hide_to_tray)

        self.ntp_server = 'pool.ntp.org'
        self.interval = 3600
        self.running = False
        self.sync_thread = None
        self.tray_icon = None

        self.create_widgets()
        self.create_tray_icon()

        # 初始化开机启动状态
        if reg:
            self.autostart_var.set(self.is_autostart_enabled())

    def create_widgets(self):
        pad = {'padx': 20, 'pady': 5}

        ttk.Label(self.root, text='NTP 服务器地址:').pack(**pad, anchor='w')
        self.server_var = tk.StringVar(value=self.ntp_server)
        ttk.Entry(self.root, textvariable=self.server_var, width=45).pack(**pad)

        ttk.Label(self.root, text='同步间隔（秒，≥10）:').pack(**pad, anchor='w')
        self.interval_var = tk.StringVar(value=str(self.interval))
        ttk.Entry(self.root, textvariable=self.interval_var, width=20).pack(**pad, anchor='w')

        btn_frame = ttk.Frame(self.root)
        btn_frame.pack(pady=8)

        self.sync_btn = ttk.Button(btn_frame, text='立即同步', command=self.manual_sync)
        self.sync_btn.pack(side='left', padx=5)

        self.start_stop_btn = ttk.Button(btn_frame, text='开始自动同步', command=self.toggle_sync)
        self.start_stop_btn.pack(side='left', padx=5)

        self.quit_btn = ttk.Button(btn_frame, text='退出', command=self.quit_app)
        self.quit_btn.pack(side='left', padx=5)

        # 开机启动复选框
        if reg:
            self.autostart_var = tk.BooleanVar()
            self.autostart_check = ttk.Checkbutton(
                self.root,
                text='开机自动启动',
                variable=self.autostart_var,
                command=self.toggle_autostart
            )
            self.autostart_check.pack(**pad, anchor='w')
        else:
            ttk.Label(self.root, text='（开机启动仅支持 Windows）', foreground='gray').pack(**pad, anchor='w')

        self.status_var = tk.StringVar(value='就绪')
        ttk.Label(self.root, textvariable=self.status_var, foreground='gray').pack(pady=5)

    def manual_sync(self):
        self._do_sync()

    def _do_sync(self):
        server = self.server_var.get().strip()
        if not server:
            messagebox.showwarning('输入错误', '请输入 NTP 服务器地址！')
            return

        self.status_var.set('正在同步...')
        self.root.update_idletasks()

        utc_time = get_ntp_time(server)
        if utc_time:
            local_time = utc_time.astimezone().replace(tzinfo=None)
            if set_system_time(local_time):
                self.status_var.set(f'✅ 同步成功: {local_time.strftime('%Y-%m-%d %H:%M:%S')}')
            else:
                self.status_var.set('❌ 设置系统时间失败（请检查权限）')
        else:
            self.status_var.set('❌ 无法连接 NTP 服务器')

    def toggle_sync(self):
        if not self.running:
            try:
                interval = int(self.interval_var.get())
                if interval < 10:
                    messagebox.showwarning('警告', '间隔不能小于10秒')
                    return
                self.interval = interval
                self.ntp_server = self.server_var.get().strip()
                if not self.ntp_server:
                    messagebox.showwarning('警告', '请输入 NTP 服务器地址')
                    return
                self.running = True
                self.start_stop_btn.config(text='停止同步')
                self.sync_thread = threading.Thread(target=self._sync_loop, daemon=True)
                self.sync_thread.start()
                self.status_var.set('自动同步已启动')
            except ValueError:
                messagebox.showerror('错误', '请输入有效的数字作为间隔时间')
        else:
            self.running = False
            self.start_stop_btn.config(text='开始自动同步')
            self.status_var.set('自动同步已停止')

    def _sync_loop(self):
        while self.running:
            self._do_sync()
            for _ in range(self.interval):
                if not self.running:
                    break
                time.sleep(1)

    def hide_to_tray(self):
        self.root.withdraw()

    def show_window(self):
        self.root.deiconify()

    def quit_app(self):
        self.running = False
        if self.tray_icon:
            self.tray_icon.stop()
        self.root.destroy()

    # ----------------------------
    # 系统托盘
    # ----------------------------

    def create_image(self):
        size = 64
        image = Image.new('RGBA', (size, size), (0, 0, 0, 0))
        draw = ImageDraw.Draw(image)
        radius = size // 2 - 4
        center = size // 2
        draw.ellipse((center - radius, center - radius, center + radius, center + radius),
                     fill=(30, 144, 255))  # DodgerBlue
        # 时钟指针
        draw.line([(center, center - radius + 10), (center, center - radius // 2)], fill='white', width=3)
        draw.line([(center + radius // 2, center), (center + radius - 10, center)], fill='white', width=3)
        return image

    def create_tray_icon(self):
        menu = (
            pystray.MenuItem('显示窗口', self.on_tray_show),
            pystray.MenuItem('退出', self.on_tray_quit)
        )
        icon = pystray.Icon('ntp_sync', self.create_image(), 'NTP同步', menu)
        self.tray_icon = icon
        threading.Thread(target=icon.run, daemon=True).start()

    def on_tray_show(self, icon, item):
        self.show_window()

    def on_tray_quit(self, icon, item):
        self.quit_app()

    # ----------------------------
    # 开机启动
    # ----------------------------

    def is_autostart_enabled(self):
        if not reg:
            return False
        try:
            key = reg.OpenKey(reg.HKEY_CURRENT_USER,
                              r'Software\Microsoft\Windows\CurrentVersion\Run',
                              0, reg.KEY_READ)
            try:
                value, _ = reg.QueryValueEx(key, 'NTP同步')
                reg.CloseKey(key)
                return bool(value)
            except FileNotFoundError:
                reg.CloseKey(key)
                return False
        except Exception:
            return False

    def toggle_autostart(self):
        if not reg:
            return
        try:
            key = reg.OpenKey(reg.HKEY_CURRENT_USER,
                              r'Software\Microsoft\Windows\CurrentVersion\Run',
                              0, reg.KEY_SET_VALUE)

            if self.autostart_var.get():
                if getattr(sys, 'frozen', False):
                    exe_path = os.path.abspath(sys.executable)
                else:
                    pythonw = sys.executable.replace('python.exe', 'pythonw.exe')
                    script = os.path.abspath(__file__)
                    exe_path = f''{pythonw}' '{script}''
                reg.SetValueEx(key, 'NTP同步', 0, reg.REG_SZ, exe_path)
            else:
                try:
                    reg.DeleteValue(key, 'NTP同步')
                except FileNotFoundError:
                    pass
            reg.CloseKey(key)
        except Exception as e:
            messagebox.showerror('错误', f'设置开机启动失败:\n{str(e)}')
            self.autostart_var.set(False)

# ----------------------------
# 主程序入口
# ----------------------------

def main():
    if not is_admin():
        run_as_admin()

    root = tk.Tk()
    app = NTPApp(root)
    root.mainloop()

if __name__ == '__main__':
    main()
```。">
<meta property="og:title" content="NTP同步软件">
<meta property="og:description" content="使用Python编写，适合windows7 32位及以上系统，整体功能纯净无广告
软件名称：NTP同步
图形界面（tkinter + 系统托盘）
自定义 NTP 服务器 & 同步间隔
无黑框（使用 pythonw 或打包后自动隐藏）
圆形蓝色托盘图标（带时钟指针）
开机启动开关按钮
通过 Windows API 设置时间
以管理员身份自动提权
兼容 Windows 7 32位 + Python 3.8

编译所需要的依赖
```
pip install ntplib pystray pillow
```
打包成软件
```
pyinstaller --onefile --windowed --name 'NTP同步' ntp_gui.py
```
⚠️ 重要提醒

- 首次运行会弹出 UAC 提权窗口（正常现象）

- 若仍提示“设置系统时间失败”，请手动授予当前用户 “更改系统时间”权限（通过 secpol.msc）
- 开机启动功能写入 当前用户 启动项，无需管理员权限

---
ntp_gui.py
```
# ntp_gui.py - NTP同步（Windows 7 32位兼容版）
# 功能：图形界面 + 系统托盘 + 开机启动 + 无黑框 + 权限提取

import os
import sys
import time
import threading
import subprocess
from datetime import datetime, timezone
import tkinter as tk
from tkinter import ttk, messagebox
import ntplib
import pystray
from PIL import Image, ImageDraw

# Windows 注册表（仅 Windows）
try:
    import winreg as reg
except ImportError:
    reg = None

# ----------------------------
# 工具函数
# ----------------------------

def is_admin():
    try:
        return os.getuid() == 0
    except AttributeError:
        import ctypes
        return ctypes.windll.shell32.IsUserAnAdmin() != 0

def run_as_admin():
    '''以管理员身份重新运行（优先使用 pythonw 避免黑框）'''
    import ctypes
    executable = sys.executable
    if executable.endswith('python.exe'):
        executable = executable[:-10] + 'pythonw.exe'
    script = os.path.abspath(sys.argv[0])
    params = f''{script}''
    try:
        ctypes.windll.shell32.ShellExecuteW(None, 'runas', executable, params, None, 1)
    except Exception:
        pass
    sys.exit(0)

def set_system_time(dt):
    '''使用 Windows API 设置系统时间（支持 Win7 32位）'''
    import ctypes
    from ctypes import wintypes

    class LUID(ctypes.Structure):
        _fields_ = [('LowPart', wintypes.DWORD), ('HighPart', wintypes.LONG)]

    class LUID_AND_ATTRIBUTES(ctypes.Structure):
        _fields_ = [('Luid', LUID), ('Attributes', wintypes.DWORD)]

    class TOKEN_PRIVILEGES(ctypes.Structure):
        _fields_ = [('PrivilegeCount', wintypes.DWORD), ('Privileges', LUID_AND_ATTRIBUTES * 1)]

    def enable_privilege(privilege_name):
        ADVAPI32 = ctypes.windll.advapi32
        KERNEL32 = ctypes.windll.kernel32
        hToken = wintypes.HANDLE()
        if not ADVAPI32.OpenProcessToken(KERNEL32.GetCurrentProcess(), 0x0028, ctypes.byref(hToken)):
            return False
        luid = LUID()
        if not ADVAPI32.LookupPrivilegeValueW(None, privilege_name, ctypes.byref(luid)):
            KERNEL32.CloseHandle(hToken)
            return False
        tp = TOKEN_PRIVILEGES()
        tp.PrivilegeCount = 1
        tp.Privileges[0].Luid = luid
        tp.Privileges[0].Attributes = 2  # SE_PRIVILEGE_ENABLED
        result = ADVAPI32.AdjustTokenPrivileges(hToken, False, ctypes.byref(tp), 0, None, None)
        success = (result != 0) and (KERNEL32.GetLastError() == 0)
        KERNEL32.CloseHandle(hToken)
        return success

    if not enable_privilege('SeSystemtimePrivilege'):
        return False

    class SYSTEMTIME(ctypes.Structure):
        _fields_ = [
            ('wYear', wintypes.WORD),
            ('wMonth', wintypes.WORD),
            ('wDayOfWeek', wintypes.WORD),
            ('wDay', wintypes.WORD),
            ('wHour', wintypes.WORD),
            ('wMinute', wintypes.WORD),
            ('wSecond', wintypes.WORD),
            ('wMilliseconds', wintypes.WORD),
        ]

    st = SYSTEMTIME()
    st.wYear = dt.year
    st.wMonth = dt.month
    st.wDay = dt.day
    st.wHour = dt.hour
    st.wMinute = dt.minute
    st.wSecond = dt.second
    st.wMilliseconds = 0

    return bool(ctypes.windll.kernel32.SetLocalTime(ctypes.byref(st)))

def get_ntp_time(ntp_server):
    client = ntplib.NTPClient()
    try:
        response = client.request(ntp_server, version=3, timeout=5)
        utc_dt = datetime.utcfromtimestamp(response.tx_time).replace(tzinfo=timezone.utc)
        return utc_dt
    except Exception:
        return None

# ----------------------------
# 主应用类
# ----------------------------

class NTPApp:
    def __init__(self, root):
        self.root = root
        self.root.title('NTP同步')
        self.root.geometry('420x260')
        self.root.resizable(False, False)
        self.root.protocol('WM_DELETE_WINDOW', self.hide_to_tray)

        self.ntp_server = 'pool.ntp.org'
        self.interval = 3600
        self.running = False
        self.sync_thread = None
        self.tray_icon = None

        self.create_widgets()
        self.create_tray_icon()

        # 初始化开机启动状态
        if reg:
            self.autostart_var.set(self.is_autostart_enabled())

    def create_widgets(self):
        pad = {'padx': 20, 'pady': 5}

        ttk.Label(self.root, text='NTP 服务器地址:').pack(**pad, anchor='w')
        self.server_var = tk.StringVar(value=self.ntp_server)
        ttk.Entry(self.root, textvariable=self.server_var, width=45).pack(**pad)

        ttk.Label(self.root, text='同步间隔（秒，≥10）:').pack(**pad, anchor='w')
        self.interval_var = tk.StringVar(value=str(self.interval))
        ttk.Entry(self.root, textvariable=self.interval_var, width=20).pack(**pad, anchor='w')

        btn_frame = ttk.Frame(self.root)
        btn_frame.pack(pady=8)

        self.sync_btn = ttk.Button(btn_frame, text='立即同步', command=self.manual_sync)
        self.sync_btn.pack(side='left', padx=5)

        self.start_stop_btn = ttk.Button(btn_frame, text='开始自动同步', command=self.toggle_sync)
        self.start_stop_btn.pack(side='left', padx=5)

        self.quit_btn = ttk.Button(btn_frame, text='退出', command=self.quit_app)
        self.quit_btn.pack(side='left', padx=5)

        # 开机启动复选框
        if reg:
            self.autostart_var = tk.BooleanVar()
            self.autostart_check = ttk.Checkbutton(
                self.root,
                text='开机自动启动',
                variable=self.autostart_var,
                command=self.toggle_autostart
            )
            self.autostart_check.pack(**pad, anchor='w')
        else:
            ttk.Label(self.root, text='（开机启动仅支持 Windows）', foreground='gray').pack(**pad, anchor='w')

        self.status_var = tk.StringVar(value='就绪')
        ttk.Label(self.root, textvariable=self.status_var, foreground='gray').pack(pady=5)

    def manual_sync(self):
        self._do_sync()

    def _do_sync(self):
        server = self.server_var.get().strip()
        if not server:
            messagebox.showwarning('输入错误', '请输入 NTP 服务器地址！')
            return

        self.status_var.set('正在同步...')
        self.root.update_idletasks()

        utc_time = get_ntp_time(server)
        if utc_time:
            local_time = utc_time.astimezone().replace(tzinfo=None)
            if set_system_time(local_time):
                self.status_var.set(f'✅ 同步成功: {local_time.strftime('%Y-%m-%d %H:%M:%S')}')
            else:
                self.status_var.set('❌ 设置系统时间失败（请检查权限）')
        else:
            self.status_var.set('❌ 无法连接 NTP 服务器')

    def toggle_sync(self):
        if not self.running:
            try:
                interval = int(self.interval_var.get())
                if interval < 10:
                    messagebox.showwarning('警告', '间隔不能小于10秒')
                    return
                self.interval = interval
                self.ntp_server = self.server_var.get().strip()
                if not self.ntp_server:
                    messagebox.showwarning('警告', '请输入 NTP 服务器地址')
                    return
                self.running = True
                self.start_stop_btn.config(text='停止同步')
                self.sync_thread = threading.Thread(target=self._sync_loop, daemon=True)
                self.sync_thread.start()
                self.status_var.set('自动同步已启动')
            except ValueError:
                messagebox.showerror('错误', '请输入有效的数字作为间隔时间')
        else:
            self.running = False
            self.start_stop_btn.config(text='开始自动同步')
            self.status_var.set('自动同步已停止')

    def _sync_loop(self):
        while self.running:
            self._do_sync()
            for _ in range(self.interval):
                if not self.running:
                    break
                time.sleep(1)

    def hide_to_tray(self):
        self.root.withdraw()

    def show_window(self):
        self.root.deiconify()

    def quit_app(self):
        self.running = False
        if self.tray_icon:
            self.tray_icon.stop()
        self.root.destroy()

    # ----------------------------
    # 系统托盘
    # ----------------------------

    def create_image(self):
        size = 64
        image = Image.new('RGBA', (size, size), (0, 0, 0, 0))
        draw = ImageDraw.Draw(image)
        radius = size // 2 - 4
        center = size // 2
        draw.ellipse((center - radius, center - radius, center + radius, center + radius),
                     fill=(30, 144, 255))  # DodgerBlue
        # 时钟指针
        draw.line([(center, center - radius + 10), (center, center - radius // 2)], fill='white', width=3)
        draw.line([(center + radius // 2, center), (center + radius - 10, center)], fill='white', width=3)
        return image

    def create_tray_icon(self):
        menu = (
            pystray.MenuItem('显示窗口', self.on_tray_show),
            pystray.MenuItem('退出', self.on_tray_quit)
        )
        icon = pystray.Icon('ntp_sync', self.create_image(), 'NTP同步', menu)
        self.tray_icon = icon
        threading.Thread(target=icon.run, daemon=True).start()

    def on_tray_show(self, icon, item):
        self.show_window()

    def on_tray_quit(self, icon, item):
        self.quit_app()

    # ----------------------------
    # 开机启动
    # ----------------------------

    def is_autostart_enabled(self):
        if not reg:
            return False
        try:
            key = reg.OpenKey(reg.HKEY_CURRENT_USER,
                              r'Software\Microsoft\Windows\CurrentVersion\Run',
                              0, reg.KEY_READ)
            try:
                value, _ = reg.QueryValueEx(key, 'NTP同步')
                reg.CloseKey(key)
                return bool(value)
            except FileNotFoundError:
                reg.CloseKey(key)
                return False
        except Exception:
            return False

    def toggle_autostart(self):
        if not reg:
            return
        try:
            key = reg.OpenKey(reg.HKEY_CURRENT_USER,
                              r'Software\Microsoft\Windows\CurrentVersion\Run',
                              0, reg.KEY_SET_VALUE)

            if self.autostart_var.get():
                if getattr(sys, 'frozen', False):
                    exe_path = os.path.abspath(sys.executable)
                else:
                    pythonw = sys.executable.replace('python.exe', 'pythonw.exe')
                    script = os.path.abspath(__file__)
                    exe_path = f''{pythonw}' '{script}''
                reg.SetValueEx(key, 'NTP同步', 0, reg.REG_SZ, exe_path)
            else:
                try:
                    reg.DeleteValue(key, 'NTP同步')
                except FileNotFoundError:
                    pass
            reg.CloseKey(key)
        except Exception as e:
            messagebox.showerror('错误', f'设置开机启动失败:\n{str(e)}')
            self.autostart_var.set(False)

# ----------------------------
# 主程序入口
# ----------------------------

def main():
    if not is_admin():
        run_as_admin()

    root = tk.Tk()
    app = NTPApp(root)
    root.mainloop()

if __name__ == '__main__':
    main()
```。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://doulifv.github.io/blog/post/NTP-tong-bu-ruan-jian.html">
<meta property="og:image" content="https://i.mji.rip/2025/10/10/233dd815c949e025f1251a319cb22724.jpeg">
<title>NTP同步软件</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">NTP同步软件</h1>
<div class="title-right">
    <a href="https://doulifv.github.io/blog" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p>使用Python编写，适合windows7 32位及以上系统，整体功能纯净无广告<br>
软件名称：NTP同步<br>
图形界面（tkinter + 系统托盘）<br>
自定义 NTP 服务器 &amp; 同步间隔<br>
无黑框（使用 pythonw 或打包后自动隐藏）<br>
圆形蓝色托盘图标（带时钟指针）<br>
开机启动开关按钮<br>
通过 Windows API 设置时间<br>
以管理员身份自动提权<br>
兼容 Windows 7 32位 + Python 3.8</p>
<p>编译所需要的依赖</p>
<pre class="notranslate"><code class="notranslate">pip install ntplib pystray pillow
</code></pre>
<p>打包成软件</p>
<pre class="notranslate"><code class="notranslate">pyinstaller --onefile --windowed --name "NTP同步" ntp_gui.py
</code></pre>
<p><g-emoji class="g-emoji" alias="warning">⚠️</g-emoji> 重要提醒</p>
<ul>
<li>
<p>首次运行会弹出 UAC 提权窗口（正常现象）</p>
</li>
<li>
<p>若仍提示“设置系统时间失败”，请手动授予当前用户 “更改系统时间”权限（通过 secpol.msc）</p>
</li>
<li>
<p>开机启动功能写入 当前用户 启动项，无需管理员权限</p>
</li>
</ul>
<hr>
<p>ntp_gui.py</p>
<pre class="notranslate"><code class="notranslate"># ntp_gui.py - NTP同步（Windows 7 32位兼容版）
# 功能：图形界面 + 系统托盘 + 开机启动 + 无黑框 + 权限提取

import os
import sys
import time
import threading
import subprocess
from datetime import datetime, timezone
import tkinter as tk
from tkinter import ttk, messagebox
import ntplib
import pystray
from PIL import Image, ImageDraw

# Windows 注册表（仅 Windows）
try:
    import winreg as reg
except ImportError:
    reg = None

# ----------------------------
# 工具函数
# ----------------------------

def is_admin():
    try:
        return os.getuid() == 0
    except AttributeError:
        import ctypes
        return ctypes.windll.shell32.IsUserAnAdmin() != 0

def run_as_admin():
    """以管理员身份重新运行（优先使用 pythonw 避免黑框）"""
    import ctypes
    executable = sys.executable
    if executable.endswith("python.exe"):
        executable = executable[:-10] + "pythonw.exe"
    script = os.path.abspath(sys.argv[0])
    params = f'"{script}"'
    try:
        ctypes.windll.shell32.ShellExecuteW(None, "runas", executable, params, None, 1)
    except Exception:
        pass
    sys.exit(0)

def set_system_time(dt):
    """使用 Windows API 设置系统时间（支持 Win7 32位）"""
    import ctypes
    from ctypes import wintypes

    class LUID(ctypes.Structure):
        _fields_ = [("LowPart", wintypes.DWORD), ("HighPart", wintypes.LONG)]

    class LUID_AND_ATTRIBUTES(ctypes.Structure):
        _fields_ = [("Luid", LUID), ("Attributes", wintypes.DWORD)]

    class TOKEN_PRIVILEGES(ctypes.Structure):
        _fields_ = [("PrivilegeCount", wintypes.DWORD), ("Privileges", LUID_AND_ATTRIBUTES * 1)]

    def enable_privilege(privilege_name):
        ADVAPI32 = ctypes.windll.advapi32
        KERNEL32 = ctypes.windll.kernel32
        hToken = wintypes.HANDLE()
        if not ADVAPI32.OpenProcessToken(KERNEL32.GetCurrentProcess(), 0x0028, ctypes.byref(hToken)):
            return False
        luid = LUID()
        if not ADVAPI32.LookupPrivilegeValueW(None, privilege_name, ctypes.byref(luid)):
            KERNEL32.CloseHandle(hToken)
            return False
        tp = TOKEN_PRIVILEGES()
        tp.PrivilegeCount = 1
        tp.Privileges[0].Luid = luid
        tp.Privileges[0].Attributes = 2  # SE_PRIVILEGE_ENABLED
        result = ADVAPI32.AdjustTokenPrivileges(hToken, False, ctypes.byref(tp), 0, None, None)
        success = (result != 0) and (KERNEL32.GetLastError() == 0)
        KERNEL32.CloseHandle(hToken)
        return success

    if not enable_privilege("SeSystemtimePrivilege"):
        return False

    class SYSTEMTIME(ctypes.Structure):
        _fields_ = [
            ('wYear', wintypes.WORD),
            ('wMonth', wintypes.WORD),
            ('wDayOfWeek', wintypes.WORD),
            ('wDay', wintypes.WORD),
            ('wHour', wintypes.WORD),
            ('wMinute', wintypes.WORD),
            ('wSecond', wintypes.WORD),
            ('wMilliseconds', wintypes.WORD),
        ]

    st = SYSTEMTIME()
    st.wYear = dt.year
    st.wMonth = dt.month
    st.wDay = dt.day
    st.wHour = dt.hour
    st.wMinute = dt.minute
    st.wSecond = dt.second
    st.wMilliseconds = 0

    return bool(ctypes.windll.kernel32.SetLocalTime(ctypes.byref(st)))

def get_ntp_time(ntp_server):
    client = ntplib.NTPClient()
    try:
        response = client.request(ntp_server, version=3, timeout=5)
        utc_dt = datetime.utcfromtimestamp(response.tx_time).replace(tzinfo=timezone.utc)
        return utc_dt
    except Exception:
        return None

# ----------------------------
# 主应用类
# ----------------------------

class NTPApp:
    def __init__(self, root):
        self.root = root
        self.root.title("NTP同步")
        self.root.geometry("420x260")
        self.root.resizable(False, False)
        self.root.protocol("WM_DELETE_WINDOW", self.hide_to_tray)

        self.ntp_server = "pool.ntp.org"
        self.interval = 3600
        self.running = False
        self.sync_thread = None
        self.tray_icon = None

        self.create_widgets()
        self.create_tray_icon()

        # 初始化开机启动状态
        if reg:
            self.autostart_var.set(self.is_autostart_enabled())

    def create_widgets(self):
        pad = {'padx': 20, 'pady': 5}

        ttk.Label(self.root, text="NTP 服务器地址:").pack(**pad, anchor='w')
        self.server_var = tk.StringVar(value=self.ntp_server)
        ttk.Entry(self.root, textvariable=self.server_var, width=45).pack(**pad)

        ttk.Label(self.root, text="同步间隔（秒，≥10）:").pack(**pad, anchor='w')
        self.interval_var = tk.StringVar(value=str(self.interval))
        ttk.Entry(self.root, textvariable=self.interval_var, width=20).pack(**pad, anchor='w')

        btn_frame = ttk.Frame(self.root)
        btn_frame.pack(pady=8)

        self.sync_btn = ttk.Button(btn_frame, text="立即同步", command=self.manual_sync)
        self.sync_btn.pack(side='left', padx=5)

        self.start_stop_btn = ttk.Button(btn_frame, text="开始自动同步", command=self.toggle_sync)
        self.start_stop_btn.pack(side='left', padx=5)

        self.quit_btn = ttk.Button(btn_frame, text="退出", command=self.quit_app)
        self.quit_btn.pack(side='left', padx=5)

        # 开机启动复选框
        if reg:
            self.autostart_var = tk.BooleanVar()
            self.autostart_check = ttk.Checkbutton(
                self.root,
                text="开机自动启动",
                variable=self.autostart_var,
                command=self.toggle_autostart
            )
            self.autostart_check.pack(**pad, anchor='w')
        else:
            ttk.Label(self.root, text="（开机启动仅支持 Windows）", foreground="gray").pack(**pad, anchor='w')

        self.status_var = tk.StringVar(value="就绪")
        ttk.Label(self.root, textvariable=self.status_var, foreground="gray").pack(pady=5)

    def manual_sync(self):
        self._do_sync()

    def _do_sync(self):
        server = self.server_var.get().strip()
        if not server:
            messagebox.showwarning("输入错误", "请输入 NTP 服务器地址！")
            return

        self.status_var.set("正在同步...")
        self.root.update_idletasks()

        utc_time = get_ntp_time(server)
        if utc_time:
            local_time = utc_time.astimezone().replace(tzinfo=None)
            if set_system_time(local_time):
                self.status_var.set(f"✅ 同步成功: {local_time.strftime('%Y-%m-%d %H:%M:%S')}")
            else:
                self.status_var.set("❌ 设置系统时间失败（请检查权限）")
        else:
            self.status_var.set("❌ 无法连接 NTP 服务器")

    def toggle_sync(self):
        if not self.running:
            try:
                interval = int(self.interval_var.get())
                if interval &lt; 10:
                    messagebox.showwarning("警告", "间隔不能小于10秒")
                    return
                self.interval = interval
                self.ntp_server = self.server_var.get().strip()
                if not self.ntp_server:
                    messagebox.showwarning("警告", "请输入 NTP 服务器地址")
                    return
                self.running = True
                self.start_stop_btn.config(text="停止同步")
                self.sync_thread = threading.Thread(target=self._sync_loop, daemon=True)
                self.sync_thread.start()
                self.status_var.set("自动同步已启动")
            except ValueError:
                messagebox.showerror("错误", "请输入有效的数字作为间隔时间")
        else:
            self.running = False
            self.start_stop_btn.config(text="开始自动同步")
            self.status_var.set("自动同步已停止")

    def _sync_loop(self):
        while self.running:
            self._do_sync()
            for _ in range(self.interval):
                if not self.running:
                    break
                time.sleep(1)

    def hide_to_tray(self):
        self.root.withdraw()

    def show_window(self):
        self.root.deiconify()

    def quit_app(self):
        self.running = False
        if self.tray_icon:
            self.tray_icon.stop()
        self.root.destroy()

    # ----------------------------
    # 系统托盘
    # ----------------------------

    def create_image(self):
        size = 64
        image = Image.new('RGBA', (size, size), (0, 0, 0, 0))
        draw = ImageDraw.Draw(image)
        radius = size // 2 - 4
        center = size // 2
        draw.ellipse((center - radius, center - radius, center + radius, center + radius),
                     fill=(30, 144, 255))  # DodgerBlue
        # 时钟指针
        draw.line([(center, center - radius + 10), (center, center - radius // 2)], fill="white", width=3)
        draw.line([(center + radius // 2, center), (center + radius - 10, center)], fill="white", width=3)
        return image

    def create_tray_icon(self):
        menu = (
            pystray.MenuItem("显示窗口", self.on_tray_show),
            pystray.MenuItem("退出", self.on_tray_quit)
        )
        icon = pystray.Icon("ntp_sync", self.create_image(), "NTP同步", menu)
        self.tray_icon = icon
        threading.Thread(target=icon.run, daemon=True).start()

    def on_tray_show(self, icon, item):
        self.show_window()

    def on_tray_quit(self, icon, item):
        self.quit_app()

    # ----------------------------
    # 开机启动
    # ----------------------------

    def is_autostart_enabled(self):
        if not reg:
            return False
        try:
            key = reg.OpenKey(reg.HKEY_CURRENT_USER,
                              r"Software\Microsoft\Windows\CurrentVersion\Run",
                              0, reg.KEY_READ)
            try:
                value, _ = reg.QueryValueEx(key, "NTP同步")
                reg.CloseKey(key)
                return bool(value)
            except FileNotFoundError:
                reg.CloseKey(key)
                return False
        except Exception:
            return False

    def toggle_autostart(self):
        if not reg:
            return
        try:
            key = reg.OpenKey(reg.HKEY_CURRENT_USER,
                              r"Software\Microsoft\Windows\CurrentVersion\Run",
                              0, reg.KEY_SET_VALUE)

            if self.autostart_var.get():
                if getattr(sys, 'frozen', False):
                    exe_path = os.path.abspath(sys.executable)
                else:
                    pythonw = sys.executable.replace("python.exe", "pythonw.exe")
                    script = os.path.abspath(__file__)
                    exe_path = f'"{pythonw}" "{script}"'
                reg.SetValueEx(key, "NTP同步", 0, reg.REG_SZ, exe_path)
            else:
                try:
                    reg.DeleteValue(key, "NTP同步")
                except FileNotFoundError:
                    pass
            reg.CloseKey(key)
        except Exception as e:
            messagebox.showerror("错误", f"设置开机启动失败:\n{str(e)}")
            self.autostart_var.set(False)

# ----------------------------
# 主程序入口
# ----------------------------

def main():
    if not is_admin():
        run_as_admin()

    root = tk.Tk()
    app = NTPApp(root)
    root.mainloop()

if __name__ == "__main__":
    main()
</code></pre></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://doulifv.github.io/blog">Forestlake</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("10/10/2025"!=""){
    var startSite=new Date("10/10/2025");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行 "+diffDay+" 天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);




function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.disabled=true;
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","doulifv/blog");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
